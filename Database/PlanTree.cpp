/*=============================================================================
# Filename: PlanTree.cpp
# Author: Linglin Yang
# Mail: fyulingi@gmail.com
=============================================================================*/


#include "PlanTree.h"
using namespace std;

// for yanglei's paper, will not used in gStore v1.0
string NodeJoinTypeStr(NodeJoinType node_join_type)
{
  switch (node_join_type) {
    case NodeJoinType::JoinANode: return "JoinANode";
    case NodeJoinType::JoinTwoTable: return "JoinTwoTable";
    case NodeJoinType::LeafNode: return "LeafNode";
  }
  return "NodeJoinType::No Exist";
}


OldPlanTree::OldPlanTree(int first_node) {
    root_node = new Old_Tree_Node(first_node);
}

OldPlanTree::OldPlanTree(OldPlanTree *last_plantree, int next_node) {
    root_node = new Old_Tree_Node();
    root_node->joinType = NodeJoinType::JoinANode;
    root_node->left_node = new Old_Tree_Node(last_plantree->root_node);
    root_node->right_node = new Old_Tree_Node(next_node);
}

OldPlanTree::OldPlanTree(OldPlanTree *left_plan, OldPlanTree *right_plan) {
    root_node = new Old_Tree_Node();
    root_node->joinType = NodeJoinType::JoinTwoTable;

    root_node->left_node = new Old_Tree_Node(left_plan->root_node);
    root_node->right_node = new Old_Tree_Node(right_plan->root_node);
}

OldPlanTree::OldPlanTree(const vector<int> nodes_order) {
	root_node = new Old_Tree_Node(nodes_order[0]);
	for(int i = 1; i < nodes_order.size(); ++i){
		Old_Tree_Node* last_plan = root_node;
		root_node = new Old_Tree_Node();
		root_node->joinType = NodeJoinType::JoinANode;
		root_node->left_node = last_plan;
		root_node->right_node = new Old_Tree_Node(nodes_order[i]);
	}
}

void OldPlanTree::delete_tree_node(Old_Tree_Node *root_node) {
    if(root_node == nullptr){
        return;
    }

    delete_tree_node(root_node->left_node);
    delete_tree_node(root_node->right_node);
    delete root_node;
}

OldPlanTree::~OldPlanTree() {
    delete_tree_node(root_node);
}


void OldPlanTree::print_tree_node(Old_Tree_Node* node, BasicQuery* basicquery){
	if(node == nullptr){
		return;
	}

	switch (node->joinType) {
		case NodeJoinType::LeafNode:
			cout << basicquery->getVarName(node->node_to_join);
			break;
		case NodeJoinType::JoinTwoTable:
			cout << "Binary join(";
			break;
		case NodeJoinType::JoinANode:
			cout << "WCO join(";
			break;
	}

	if(node->left_node!= nullptr){
		print_tree_node(node->left_node, basicquery);
		cout << ",";
		print_tree_node(node->right_node, basicquery);
	}

	if(node->joinType!=NodeJoinType::LeafNode){
		cout << ")";
	}
}

void OldPlanTree::print(BasicQuery* basicquery) {
	cout << "Plan: ";
	print_tree_node(root_node, basicquery);
	cout << ", cost: "<<this->plan_cost;
	cout << endl;
}


// codes below will be used in gStore v1.0

JoinMethod Tree_node::get_join_method(bool s_is_var, bool p_is_var, bool o_is_var) {

	int var_num = 0;
	if(s_is_var) var_num += 1;
	if(p_is_var) var_num += 1;
	if(o_is_var) var_num += 1;

	// todo: this is a question, what about a triple like ?s ?p ?o ?
	if(var_num == 2){
		if(!s_is_var) return JoinMethod::s2po;
		if(!o_is_var) return JoinMethod::o2ps;
		if(!p_is_var) return JoinMethod::p2so;
	} else if(var_num == 1){
		if(s_is_var) return JoinMethod::po2s;
		if(o_is_var) return JoinMethod::sp2o;
		if(p_is_var) return JoinMethod::so2p;
	} else{
		cout << "error: var_num not equal to 1 or 2" << endl;
		exit(-1);
	}
    assert(false);
}

Tree_node::Tree_node(unsigned int node_id, BGPQuery *bgpquery, bool is_first_node) {

	// codes below are for is_first_node == true, I will remove param is first_node from this fun.
	// If node_id is not the first node,
	// then the tree_node should be generated by some funs like
	// Tree_node(unsigned node_id, set<unsigned> already_id);
	auto edge_info = make_shared<vector<EdgeInfo>>();
	auto edge_constant_info = make_shared<vector<EdgeConstantInfo>>();

	auto var_descrip = bgpquery->get_vardescrip_by_id(node_id);

	auto var_degree = var_descrip->degree_;

	if(var_descrip->var_type_ == VarDescriptor::VarType::Entity){
		for(unsigned i_th_edge = 0; i_th_edge < var_degree; ++ i_th_edge){
			if(var_descrip->so_edge_pre_type_[i_th_edge] != VarDescriptor::PreType::VarPreType ||
					var_descrip->so_edge_nei_type_[i_th_edge] != VarDescriptor::EntiType::VarEntiType){
				unsigned triple_id = var_descrip->so_edge_index_[i_th_edge];

				unsigned constant_num = 0;
				if(bgpquery->s_is_constant_[triple_id]) constant_num += 1;
				if(bgpquery->p_is_constant_[triple_id]) constant_num += 1;
				if(bgpquery->o_is_constant_[triple_id]) constant_num += 1;

				JoinMethod join_method;
				if(constant_num == 2){
					if(var_descrip->so_edge_type_[i_th_edge] == Util::EDGE_IN)
						join_method = JoinMethod::sp2o;
					else
						join_method = JoinMethod::po2s;
				} else{
					if(bgpquery->p_is_constant_[triple_id]){
						if(var_descrip->so_edge_type_[i_th_edge] == Util::EDGE_IN)
							// ?s p ?o, ?o is the var_descrip
							join_method = JoinMethod::p2o;
						else
							join_method = JoinMethod::p2s;
					} else{
						if(var_descrip->so_edge_type_[i_th_edge] == Util::EDGE_IN)
							// s ?p ?o, ?o is the var_descrip
							join_method = JoinMethod::s2o;
						else
							join_method = JoinMethod::o2s;
					}
				}

				edge_info->emplace_back(bgpquery->s_id_[triple_id], bgpquery->p_id_[triple_id], bgpquery->o_id_[triple_id], join_method);
				edge_constant_info->emplace_back(bgpquery->s_is_constant_[triple_id], bgpquery->p_is_constant_[triple_id], bgpquery->o_is_constant_[triple_id]);

			}

		}
	} else{
		for(unsigned i_th_edge = 0; i_th_edge < var_degree; ++ i_th_edge){
			if(var_descrip->s_type_[i_th_edge] != VarDescriptor::EntiType::VarEntiType &&
					var_descrip->o_type_[i_th_edge] != VarDescriptor::EntiType::VarEntiType){
				unsigned triple_id = var_descrip->pre_edge_index_[i_th_edge];
				unsigned constant_num = 0;
				if(bgpquery->s_is_constant_[triple_id]) constant_num += 1;
				if(bgpquery->o_is_constant_[triple_id]) constant_num += 1;

				JoinMethod join_method;
				if(constant_num == 2){

					join_method = JoinMethod::so2p;
				} else{
					if(bgpquery->s_is_constant_[triple_id])
						join_method = JoinMethod::s2p;
					else
						join_method = JoinMethod::o2p;
				}


				edge_info->emplace_back(bgpquery->s_id_[triple_id], bgpquery->p_id_[triple_id], bgpquery->o_id_[triple_id], join_method);
				edge_constant_info->emplace_back(bgpquery->s_is_constant_[triple_id], bgpquery->p_is_constant_[triple_id], bgpquery->o_is_constant_[triple_id]);

			}

		}
	}

	auto one_step_join_node = make_shared<FeedOneNode>();
	one_step_join_node->node_to_join_ = node_id;
	one_step_join_node->edges_ = edge_info;
	one_step_join_node->edges_constant_info_ = edge_constant_info;

	node = make_shared<StepOperation>();
	// if(is_first_node){
	// 	node->join_type_ = StepOperation::JoinType::GenerateCandidates;
	// 	node->edge_filter_ = one_step_join_node;
	//
	// } else{
	// 	node->join_type_ = StepOperation::JoinType::JoinNode;
	// 	node->join_node_ = one_step_join_node;
	// }

	node->join_type_ = StepOperation::JoinType::JoinNode;
	node->join_node_ = one_step_join_node;
	left_node = nullptr;
	right_node = nullptr;
}

Tree_node::Tree_node(unsigned node_id, set<unsigned> already_in, BGPQuery *bgpquery) {
	auto edge_info = make_shared<vector<EdgeInfo>>();
	auto edge_constant_info = make_shared<vector<EdgeConstantInfo>>();

	auto var_descrip = bgpquery->get_vardescrip_by_id(node_id);

	auto var_degree = var_descrip->degree_;

	if(var_descrip->var_type_ == VarDescriptor::VarType::Entity){
		for(unsigned i_th_edge = 0; i_th_edge < var_degree; ++ i_th_edge){

			// first deal with const edge
			// TODO: zhou yuqi can remove this
			if(var_descrip->so_edge_pre_type_[i_th_edge] == VarDescriptor::PreType::ConPreType &&
					var_descrip->so_edge_nei_type_[i_th_edge] == VarDescriptor::EntiType::ConEntiType){
				// deal with ?s p o or s p ?o
				// todo: constant edge should be dealed first
				unsigned triple_id = var_descrip->so_edge_index_[i_th_edge];

				JoinMethod join_method;
				if(var_descrip->so_edge_type_[i_th_edge] == Util::EDGE_IN)
					// s p ?o
					join_method = JoinMethod::sp2o;
				else
					// ?s p o
					join_method = JoinMethod::po2s;

				edge_info->emplace_back(bgpquery->s_id_[triple_id], bgpquery->p_id_[triple_id], bgpquery->o_id_[triple_id], join_method);
				edge_constant_info->emplace_back(bgpquery->s_is_constant_[triple_id], bgpquery->p_is_constant_[triple_id], bgpquery->o_is_constant_[triple_id]);

			}

			if((var_descrip->so_edge_pre_type_[i_th_edge] == VarDescriptor::PreType::VarPreType &&
					already_in.count(var_descrip->so_edge_pre_id_[i_th_edge]) == 1)  ||
				(var_descrip->so_edge_nei_type_[i_th_edge] == VarDescriptor::EntiType::VarEntiType &&
			   		already_in.count(var_descrip->so_edge_nei_[i_th_edge] == 1))){

				// deal with edge linked with var in already_in
				unsigned triple_id = var_descrip->so_edge_index_[i_th_edge];

				bool s_is_const = (bgpquery->s_is_constant_[triple_id]);
				bool p_is_const = (bgpquery->p_is_constant_[triple_id]);
				bool o_is_const = (bgpquery->o_is_constant_[triple_id]);

				unsigned const_num = 0;
				if(s_is_const) const_num += 1;
				if(p_is_const) const_num += 1;
				if(o_is_const) const_num += 1;

				JoinMethod join_method;

				if(const_num == 1){
					// var_num == 2, var_descrip is a var, so the another var must be in already_in
					if(var_descrip->so_edge_type_[i_th_edge] == Util::EDGE_IN)
						// (s ?p ?o) or (?s p ?o), ?o is the var_descrip
						join_method = JoinMethod::sp2o;
					else
						// (?s ?p o) or (?s p ?o), ?s is the var_descrip
						join_method = JoinMethod::po2s;
				} else{
					// ?s ?p ?o
					if(already_in.count(bgpquery->p_id_[triple_id]) == 1){
						// ?p in already_in
						if(var_descrip->so_edge_type_[i_th_edge] == Util::EDGE_IN)
							// var_descrip is ?o
							if(already_in.count(bgpquery->s_id_[triple_id]) == 1)
								// ?s in already_in
								join_method = JoinMethod::sp2o;
							else
								// ?s not in already_in
								join_method = JoinMethod::p2o;
						else
							// var_descrip is ?s
							if(already_in.count(bgpquery->o_id_[triple_id]) == 1)
								// ?o is in already_in
								join_method = JoinMethod::po2s;
							else
								// ?o not in already_in
								join_method = JoinMethod::p2s;
					} else{
						// ?p not in already_in
						if(var_descrip->so_edge_type_[i_th_edge] == Util::EDGE_IN)
							// var_descrip is ?o
							if(already_in.count(bgpquery->s_id_[triple_id]) == 1)
								// ?s in already_in
								join_method = JoinMethod::s2o;
							else{
								// ?s not in already_in,
								// then ?p, ?s both not in already, conflict with the if condition
								cout << "error: if error!" << endl;
								exit(-1);
							}
						else
							// var_descrip is ?s
							if(already_in.count(bgpquery->o_id_[triple_id]) == 1)
								// ?o is in already_in
								join_method = JoinMethod::o2s;
							else{
								// ?o not in already_in,
								// then ?p, ?s both not in already, conflict with the if condition
								cout << "error: if error!" << endl;
								exit(-1);
							}
					}
				}

				edge_info->emplace_back(bgpquery->s_id_[triple_id], bgpquery->p_id_[triple_id], bgpquery->o_id_[triple_id], join_method);
				edge_constant_info->emplace_back(bgpquery->s_is_constant_[triple_id], bgpquery->p_is_constant_[triple_id], bgpquery->o_is_constant_[triple_id]);

			}

		}
	} else{
		// node_id is a pre var
		// TODO: zhou yuqi can remove this
		for(unsigned i_th_edge = 0; i_th_edge < var_degree; ++ i_th_edge){
			if(var_descrip->s_type_[i_th_edge] == VarDescriptor::EntiType::ConEntiType &&
					var_descrip->o_type_[i_th_edge] == VarDescriptor::EntiType::ConEntiType){

				unsigned triple_id = var_descrip->pre_edge_index_[i_th_edge];

				JoinMethod join_method = JoinMethod::so2p;

				edge_info->emplace_back(bgpquery->s_id_[triple_id], bgpquery->p_id_[triple_id], bgpquery->o_id_[triple_id], join_method);
				edge_constant_info->emplace_back(bgpquery->s_is_constant_[triple_id], bgpquery->p_is_constant_[triple_id], bgpquery->o_is_constant_[triple_id]);

			}

			if((var_descrip->s_type_[i_th_edge] == VarDescriptor::EntiType::VarEntiType &&
					already_in.count(var_descrip->s_id_[i_th_edge]) == 1) ||
				(var_descrip->o_type_[i_th_edge] == VarDescriptor::EntiType::VarEntiType &&
					already_in.count(var_descrip->o_id_[i_th_edge]) == 1)){

				unsigned triple_id = var_descrip->pre_edge_index_[i_th_edge];

				unsigned const_num = 0;
				bool s_is_const = bgpquery->s_is_constant_[triple_id];
				bool o_is_const = bgpquery->o_is_constant_[triple_id];

				if(s_is_const) const_num += 1;
				if(o_is_const) const_num += 1;

				JoinMethod join_method;

				if(const_num == 1){
					// (s ?p ?o) or (?s ?p o), ?p is the var_descrip, ?s or ?o in already_in
					join_method = JoinMethod::so2p;
				} else{
					// const_num == 0, ?s ?p ?o, ?p is the var_descrip
					if(already_in.count(var_descrip->s_id_[i_th_edge]) == 1)
						if(already_in.count(var_descrip->o_id_[i_th_edge]) == 1)
							// ?s ?p ?o, ?s and ?o are in already_in
							join_method = JoinMethod::so2p;
						else
							join_method = JoinMethod::s2p;
					else
						if(already_in.count(var_descrip->o_id_[i_th_edge]) == 1)
							join_method = JoinMethod::o2p;
						else{
							// ?s ?p ?o, ?s and ?o neither in already_in, conflict with if condition
							cout << "error: if error!" << endl;
							exit(-1);
						}
				}

				edge_info->emplace_back(bgpquery->s_id_[triple_id], bgpquery->p_id_[triple_id], bgpquery->o_id_[triple_id], join_method);
				edge_constant_info->emplace_back(bgpquery->s_is_constant_[triple_id], bgpquery->p_is_constant_[triple_id], bgpquery->o_is_constant_[triple_id]);

			}

		}
	}

	auto one_step_join_node = make_shared<FeedOneNode>();
	one_step_join_node->node_to_join_ = node_id;
	one_step_join_node->edges_ = edge_info;
	one_step_join_node->edges_constant_info_ = edge_constant_info;

	node = make_shared<StepOperation>();
	node->join_type_ = StepOperation::JoinType::JoinNode;
	node->join_node_ = one_step_join_node;
}

PlanTree::PlanTree(int first_node) {
	root_node = new Tree_node(first_node);
}

PlanTree::PlanTree(PlanTree *last_plantree, int next_node) {
	root_node = new Tree_node();
	root_node->joinType = NodeJoinType::JoinANode;
	root_node->left_node = new Tree_node(last_plantree->root_node);
	root_node->right_node = new Tree_node(next_node);
}

PlanTree::PlanTree(PlanTree *left_plan, PlanTree *right_plan) {
	root_node = new Tree_node();
	root_node->joinType = NodeJoinType::JoinTwoTable;

	root_node->left_node = new Tree_node(left_plan->root_node);
	root_node->right_node = new Tree_node(right_plan->root_node);
}


// todo: not complete
PlanTree::PlanTree(unsigned int first_node, BGPQuery *bgpquery) {
	root_node = new Tree_node(first_node, bgpquery, true);
	// todo: if used in normal plan (invoked by optimizer), then should give its cost
}

PlanTree::PlanTree(shared_ptr<StepOperation> &first_node) {
	root_node = new Tree_node(first_node);
}


/**
 * Build plantree for adding one node (FeedOneNode type) to last_plan_tree
 * @param last_plan_tree plan tree need adding one node
 * @param next_join_var_id the id of added node
 * @param already_id node ids in last_plan_tree
 * @param bgpquery bgp information of the query
 */
PlanTree::PlanTree(PlanTree *last_plan_tree, unsigned int next_join_var_id, set<unsigned> already_id, BGPQuery *bgpquery) {
	root_node = new Tree_node(next_join_var_id, already_id, bgpquery);
	root_node->left_node = new Tree_node(last_plan_tree->root_node, true);
	root_node->right_node = nullptr;

}

PlanTree::PlanTree(const vector<int> nodes_order) {
	root_node = new Tree_node(nodes_order[0]);
	for(int i = 1; i < nodes_order.size(); ++i){
		Tree_node* last_plan = root_node;
		root_node = new Tree_node();
		root_node->joinType = NodeJoinType::JoinANode;
		root_node->left_node = last_plan;
		root_node->right_node = new Tree_node(nodes_order[i]);
	}
}

void PlanTree::delete_tree_node(Tree_node *root_node) {
	if(root_node == nullptr){
		return;
	}

	delete_tree_node(root_node->left_node);
	delete_tree_node(root_node->right_node);
	delete root_node;
}

PlanTree::~PlanTree() {
	delete_tree_node(root_node);
}


void PlanTree::print_tree_node(Tree_node* node, BasicQuery* basicquery){
	if(node == nullptr){
		return;
	}

	switch (node->joinType) {
		case NodeJoinType::LeafNode:
			cout << basicquery->getVarName(node->node_to_join);
			break;
			case NodeJoinType::JoinTwoTable:
				cout << "Binary join(";
				break;
				case NodeJoinType::JoinANode:
					cout << "WCO join(";
					break;
	}

	if(node->left_node!= nullptr){
		print_tree_node(node->left_node, basicquery);
		cout << ",";
		print_tree_node(node->right_node, basicquery);
	}

	if(node->joinType!=NodeJoinType::LeafNode){
		cout << ")";
	}
}

void PlanTree::print(BasicQuery* basicquery) {
	cout << "Plan: ";
	print_tree_node(root_node, basicquery);
	cout << ", cost: "<<this->plan_cost;
	cout << endl;
}

void PlanTree::print_tree_node(Tree_node *node, BGPQuery *bgpquery) {
	if(node == nullptr)
		return;
	if(node->left_node != nullptr)
		print_tree_node(node->left_node, bgpquery);
	if(node->right_node != nullptr)
		print_tree_node(node->right_node, bgpquery);

	auto stepoperation = node->node;
	cout << "join type: " << stepoperation->JoinTypeToString(stepoperation->join_type_) << endl;
	switch (stepoperation->join_type_) {
		case StepOperation::JoinType::GenerateCandidates:{
			for(unsigned i = 0; i < stepoperation->edge_filter_->edges_->size(); ++ i){
				cout << "edge[" << i << "]:" << endl;
				cout << "\t\ts[" << (*stepoperation->edge_filter_->edges_)[i].s_ << "]" << ((*stepoperation->edge_filter_->edges_constant_info_)[i].s_constant_ ? "const" : "var") << '\t';
				cout << "p[" << (*stepoperation->edge_filter_->edges_)[i].p_ << "]" << ((*stepoperation->edge_filter_->edges_constant_info_)[i].p_constant_ ? "const" : "var") << '\t';
				cout << "o[" << (*stepoperation->edge_filter_->edges_)[i].o_ << "]" << ((*stepoperation->edge_filter_->edges_constant_info_)[i].o_constant_ ? "const" : "var") << endl;
			}
			cout << "node id: " << stepoperation->edge_filter_->node_to_join_ << endl;
		}
		case StepOperation::JoinType::JoinNode:{
			for(unsigned i = 0; i < stepoperation->join_node_->edges_->size(); ++ i){
				cout << "\tedge[" << i << "]:" << endl;
				cout << "\t\ts[" << (*stepoperation->join_node_->edges_)[i].s_ << "]" << ((*stepoperation->join_node_->edges_constant_info_)[i].s_constant_ ? "const" : "var") << "    ";
				cout << "p[" << (*stepoperation->join_node_->edges_)[i].p_ << "]" << ((*stepoperation->join_node_->edges_constant_info_)[i].p_constant_ ? "const" : "var") << "    ";
				cout << "o[" << (*stepoperation->join_node_->edges_)[i].o_ << "]" << ((*stepoperation->join_node_->edges_constant_info_)[i].o_constant_ ? "const" : "var") << "    ";
				cout << JoinMethodToString((*stepoperation->join_node_->edges_)[i].join_method_) << endl;
			}
			cout << "\tnode id: " << stepoperation->join_node_->node_to_join_ << endl;
		}

	}


}

void PlanTree::print(BGPQuery* bgpquery) {
	cout << "Plan: " << endl;
	// todo: not complete
	print_tree_node(root_node, bgpquery);
}